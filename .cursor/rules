# Reglas de Desarrollo - CarSharing Service App

## ðŸŽ¯ VisiÃ³n General

Este proyecto es una aplicaciÃ³n React Native/Expo para un servicio de car-sharing. Sigue principios de desarrollo de alta calidad, TDD, seguridad y mejores prÃ¡cticas de la industria.

> **ðŸ“š Agents Especializados:** Este proyecto incluye agents especializados en `.cursor/agents/` que proporcionan conocimiento detallado en Ã¡reas especÃ­ficas. Consulta `.cursor/agents/README.md` para ver la lista completa y cuÃ¡ndo usar cada uno.

---

## ðŸ› ï¸ Stack TecnolÃ³gico

### Core Technologies

- **React Native**: 0.73.0
- **Expo**: ~50.0.0
- **Expo Router**: ~3.4.0 (file-based routing)
- **TypeScript**: 5.1.3 (strict mode)
- **TanStack React Query**: ^5.0.0 (data fetching & state management)

### Key Libraries

- `expo-secure-store`: Almacenamiento seguro de tokens
- `expo-local-authentication`: AutenticaciÃ³n biomÃ©trica
- `react-native-reanimated`: Animaciones de alto rendimiento
- `react-native-gesture-handler`: Gestos nativos
- `react-native-toast-message`: Notificaciones al usuario

---

## ðŸ“ Arquitectura y Patrones

> **ðŸ“š Referencia especializada:** Consulta `.cursor/agents/architect-reviewer.md` para evaluaciÃ³n de arquitectura, patrones de diseÃ±o, escalabilidad, y decisiones tÃ©cnicas estratÃ©gicas.

### Atomic Design Pattern

```
components/
  â”œâ”€â”€ atoms/        # Componentes bÃ¡sicos (Button, Input, Card)
  â”œâ”€â”€ molecules/    # Componentes compuestos (FiltersSheet, PinInput)
  â””â”€â”€ organisms/    # Componentes complejos (formularios completos)
```

**Reglas:**

- Los Ã¡tomos son componentes bÃ¡sicos sin dependencias de otros componentes UI
- Las molÃ©culas combinan Ã¡tomos
- Los organismos combinan molÃ©culas y Ã¡tomos
- Cada componente debe tener un propÃ³sito Ãºnico y claro
- Exportar componentes a travÃ©s de `index.ts` para imports limpios

### Service Layer Pattern

```
services/
  â”œâ”€â”€ modes/
  â”‚   â”œâ”€â”€ mock/     # ImplementaciÃ³n mock para desarrollo/testing
  â”‚   â””â”€â”€ rest/     # ImplementaciÃ³n REST real
  â””â”€â”€ apiClient.ts  # Cliente HTTP centralizado
```

**Reglas:**

- Todos los servicios deben tener interfaces TypeScript definidas
- Implementar siempre ambas versiones (mock y rest)
- Usar el patrÃ³n Strategy para intercambiar entre modos
- El `apiClient` maneja autenticaciÃ³n, refresh tokens y errores globalmente

### Custom Hooks Pattern

```
hooks/
  â”œâ”€â”€ useAuth.ts      # LÃ³gica de autenticaciÃ³n
  â”œâ”€â”€ useVehicles.ts  # LÃ³gica de vehÃ­culos
  â””â”€â”€ useBooking.ts   # LÃ³gica de reservas
```

**Reglas:**

- Un hook por dominio de negocio
- Los hooks encapsulan lÃ³gica compleja y estado
- Usar TanStack Query para operaciones async
- Mantener hooks simples y enfocados (Single Responsibility)

---

## ðŸ”’ Seguridad

> **ðŸ“š Referencia especializada:** Consulta `.cursor/agents/security-auditor.md` para auditorÃ­as de seguridad detalladas, checklist completo, y mejores prÃ¡cticas avanzadas.

### AutenticaciÃ³n y Tokens

- âœ… **NUNCA** almacenar tokens en AsyncStorage o estado plano
- âœ… Usar `expo-secure-store` para refresh tokens
- âœ… Access tokens solo en memoria (no persistir)
- âœ… Implementar refresh automÃ¡tico de tokens antes de expirar
- âœ… Limpiar tokens al hacer logout
- âœ… Validar tokens en el lado del servidor siempre

### Datos Sensibles

- âœ… **NUNCA** hardcodear credenciales, API keys o secrets
- âœ… Usar variables de entorno con prefijo `EXPO_PUBLIC_` para variables pÃºblicas
- âœ… **NUNCA** exponer secrets en el cliente (usar solo en backend)
- âœ… Validar y sanitizar todas las entradas del usuario
- âœ… Usar HTTPS siempre para comunicaciÃ³n con API

### Manejo de Errores

- âœ… No exponer detalles tÃ©cnicos de errores al usuario
- âœ… No loguear informaciÃ³n sensible en producciÃ³n
- âœ… Usar cÃ³digos de error genÃ©ricos para errores de autenticaciÃ³n
- âœ… Implementar rate limiting en el cliente

### BiometrÃ­a

- âœ… Usar `expo-local-authentication` para autenticaciÃ³n biomÃ©trica
- âœ… Solicitar permiso antes de usar biometrÃ­a
- âœ… Tener fallback a contraseÃ±a siempre disponible
- âœ… No almacenar datos biomÃ©tricos, solo usarlos para autenticaciÃ³n

---

## ðŸ§ª Test-Driven Development (TDD)

> **ðŸ“š Referencia especializada:** Consulta `.cursor/agents/qa-expert.md` para estrategias completas de testing, test coverage, y metodologÃ­as de QA.

### Ciclo Red-Green-Refactor

1. **Red**: Escribir test que falle (describe el comportamiento deseado)
2. **Green**: Escribir cÃ³digo mÃ­nimo para pasar el test
3. **Refactor**: Mejorar cÃ³digo manteniendo tests pasando

### Estructura de Tests

```
__tests__/
  â”œâ”€â”€ components/
  â”‚   â”œâ”€â”€ atoms/
  â”‚   â”œâ”€â”€ molecules/
  â”‚   â””â”€â”€ organisms/
  â”œâ”€â”€ hooks/
  â”œâ”€â”€ services/
  â”œâ”€â”€ utils/
  â””â”€â”€ integration/
```

### Reglas de Testing

- âœ… Escribir tests ANTES de implementar funcionalidad
- âœ… Un test debe verificar una sola cosa
- âœ… Tests deben ser independientes (no depender de otros)
- âœ… Usar nombres descriptivos: `describe('useAuth', () => { it('should logout user and clear tokens', ...) })`
- âœ… Mantener cobertura mÃ­nima del 80% para cÃ³digo crÃ­tico
- âœ… Mockear dependencias externas (API, SecureStore, etc.)

### Tipos de Tests Requeridos

1. **Unit Tests**: Componentes, hooks, utilities
2. **Integration Tests**: Flujos completos (login â†’ browse â†’ booking)
3. **E2E Tests**: Flujos crÃ­ticos de usuario (usar Detox o similar)

### Testing de Hooks

```typescript
// âœ… BUENO: Testear comportamiento, no implementaciÃ³n
it('should login user and navigate to browse', async () => {
  const { result } = renderHook(() => useAuth());
  await act(async () => {
    await result.current.login({ email: 'test@test.com', password: 'pass' });
  });
  expect(result.current.isAuthenticated).toBe(true);
});

// âŒ MALO: Testear implementaciÃ³n interna
it('should call apiClient.post', ...);
```

---

## ðŸ“ TypeScript

> **ðŸ“š Referencia especializada:** Consulta `.cursor/agents/typescript-pro.md` para patrones avanzados de tipos, type guards, generics, y optimizaciÃ³n de builds.

### ConfiguraciÃ³n Strict

- âœ… `strict: true` siempre activado
- âœ… Usar tipos explÃ­citos, evitar `any`
- âœ… Usar `unknown` para valores desconocidos
- âœ… Definir interfaces para todas las estructuras de datos
- âœ… Usar tipos uniÃ³n para valores especÃ­ficos: `type ApiMode = 'mock' | 'live'`

### Reglas de Tipado

```typescript
// âœ… BUENO: Tipos explÃ­citos
interface User {
  id: string;
  email: string;
  name: string;
}

const getUser = async (id: string): Promise<User> => { ... };

// âŒ MALO: any implÃ­cito
const getUser = async (id) => { ... };
```

### Tipos de Servicios

- âœ… Definir tipos para requests y responses
- âœ… Usar tipos genÃ©ricos para reutilizaciÃ³n
- âœ… Crear tipos compartidos en `services/types.ts`
- âœ… Usar `ApiResponse<T>` para respuestas de API

---

## âš›ï¸ React Native / Expo

> **ðŸ“š Referencias especializadas:**
>
> - `.cursor/agents/react-specialist.md` - Patrones avanzados de React, hooks, performance
> - `.cursor/agents/mobile-developer.md` - Desarrollo mÃ³vil cross-platform, optimizaciÃ³n, native modules

### Componentes

- âœ… Usar Functional Components con hooks
- âœ… Evitar re-renders innecesarios con `React.memo` cuando sea apropiado
- âœ… Usar `useMemo` y `useCallback` para optimizaciones (solo cuando necesario)
- âœ… Extraer lÃ³gica compleja a custom hooks
- âœ… Mantener componentes pequeÃ±os (< 200 lÃ­neas)

### NavegaciÃ³n (Expo Router)

- âœ… Usar file-based routing de Expo Router
- âœ… Grupos de rutas con `(auth)` y `(tabs)` para organizaciÃ³n
- âœ… Usar `router.push()` para navegaciÃ³n programÃ¡tica
- âœ… Validar parÃ¡metros de ruta con TypeScript

### Performance

- âœ… Usar `FlatList` en lugar de `ScrollView` para listas largas
- âœ… Implementar `keyExtractor` y `getItemLayout` en listas
- âœ… Lazy loading de imÃ¡genes con `expo-image`
- âœ… Usar `react-native-reanimated` para animaciones (worklet)
- âœ… Evitar cÃ¡lculos pesados en render, usar `useMemo`

### Estado y Data Fetching

- âœ… Usar TanStack Query para todas las operaciones async
- âœ… Configurar `staleTime` y `cacheTime` apropiadamente
- âœ… Usar `useQuery` para datos de lectura
- âœ… Usar `useMutation` para operaciones de escritura
- âœ… Invalidar queries despuÃ©s de mutaciones

```typescript
// âœ… BUENO: Usar React Query
const { data, isLoading } = useQuery({
  queryKey: ["vehicles", filters],
  queryFn: () => getVehicles(filters),
  staleTime: 5 * 60 * 1000, // 5 minutos
});

// âŒ MALO: useState + useEffect para fetching
const [vehicles, setVehicles] = useState([]);
useEffect(() => {
  fetchVehicles().then(setVehicles);
}, []);
```

---

## ðŸŽ¨ Estilos y UI

> **ðŸ“š Referencia especializada:** Consulta `.cursor/agents/ux-researcher.md` para metodologÃ­as de investigaciÃ³n UX, pruebas de usabilidad, anÃ¡lisis de comportamiento, accesibilidad avanzada, y mejores prÃ¡cticas de diseÃ±o centrado en el usuario.

### Design Tokens

- âœ… Usar tokens de diseÃ±o centralizados (`theme/tokens.ts`)
- âœ… No hardcodear colores, spacing, etc.
- âœ… Mantener consistencia visual
- âœ… Soporte para dark mode (usar `useColorScheme`)

### Componentes Reutilizables

- âœ… Crear componentes genÃ©ricos y reutilizables
- âœ… Usar props para variaciones, no duplicar componentes
- âœ… Documentar props con TypeScript y JSDoc

### Accesibilidad

- âœ… Agregar `accessibilityLabel` a elementos interactivos
- âœ… Usar `accessibilityRole` apropiado
- âœ… Soporte para lectores de pantalla
- âœ… Contraste adecuado de colores (WCAG AA mÃ­nimo)

---

## ðŸ”„ Manejo de Errores

### Error Boundaries

- âœ… Implementar error boundaries para capturar errores de React
- âœ… Mostrar UI de fallback amigable
- âœ… Loguear errores para debugging

### API Errors

- âœ… Usar tipos estructurados para errores (`ApiError`)
- âœ… Manejar errores especÃ­ficos (401, 403, 404, 500)
- âœ… Mostrar mensajes de error amigables al usuario
- âœ… Implementar retry logic para errores transitorios

```typescript
// âœ… BUENO: Manejo estructurado de errores
try {
  const result = await apiClient.get("/vehicles");
  if (!result.success) {
    showToast(result.error.message);
    return;
  }
  // usar result.data
} catch (error) {
  showToast("Error de conexiÃ³n. Intenta de nuevo.");
}
```

---

## ðŸ“¦ GestiÃ³n de Dependencias

### Agregar Nuevas Dependencias

- âœ… Verificar compatibilidad con React Native/Expo
- âœ… Revisar bundle size (usar `expo-doctor`)
- âœ… Preferir librerÃ­as mantenidas activamente
- âœ… Verificar licencias compatibles
- âœ… Documentar razÃ³n de la dependencia

### Versionado

- âœ… Usar versiones exactas para dependencias crÃ­ticas
- âœ… Actualizar dependencias regularmente
- âœ… Probar actualizaciones en branch separado
- âœ… Revisar changelog antes de actualizar

---

## ðŸš€ Performance y OptimizaciÃ³n

> **ðŸ“š Referencias especializadas:**
>
> - `.cursor/agents/mobile-developer.md` - OptimizaciÃ³n mÃ³vil, profiling, native performance
> - `.cursor/agents/react-specialist.md` - OptimizaciÃ³n de React, memoization, code splitting

### Bundle Size

- âœ… Monitorear tamaÃ±o del bundle
- âœ… Usar tree-shaking (imports especÃ­ficos)
- âœ… Lazy load de pantallas no crÃ­ticas
- âœ… Optimizar imÃ¡genes y assets

### Memory Management

- âœ… Limpiar subscriptions y listeners en `useEffect` cleanup
- âœ… Evitar memory leaks con referencias a objetos grandes
- âœ… Usar `useRef` para valores que no necesitan re-render

### Network

- âœ… Implementar cachÃ© apropiado con React Query
- âœ… Usar debounce/throttle para bÃºsquedas
- âœ… Implementar paginaciÃ³n para listas grandes
- âœ… Prefetch datos que probablemente se necesiten

---

## ðŸ“š Convenciones de CÃ³digo

### Naming

- âœ… Componentes: PascalCase (`UserProfile.tsx`)
- âœ… Hooks: camelCase con prefijo `use` (`useAuth.ts`)
- âœ… Utilidades: camelCase (`formatDate.ts`)
- âœ… Constantes: UPPER_SNAKE_CASE (`API_BASE_URL`)
- âœ… Tipos/Interfaces: PascalCase (`User`, `ApiResponse`)

### Imports

- âœ… Orden: React â†’ librerÃ­as externas â†’ internas â†’ relativos
- âœ… Usar absolute imports cuando sea posible (`@/components`)
- âœ… Agrupar imports relacionados

```typescript
// âœ… BUENO: Imports organizados
import { useEffect } from "react";
import { router } from "expo-router";
import { useQuery } from "@tanstack/react-query";
import { Button } from "@/components/atoms";
import { useAuth } from "../hooks";
```

### Comentarios y DocumentaciÃ³n

- âœ… Documentar funciones complejas con JSDoc
- âœ… Usar comentarios para explicar "por quÃ©", no "quÃ©"
- âœ… Mantener comentarios actualizados
- âœ… Eliminar cÃ³digo comentado

```typescript
// âœ… BUENO: DocumentaciÃ³n Ãºtil
/**
 * Refresca el access token usando el refresh token almacenado.
 * Previene mÃºltiples llamadas simultÃ¡neas de refresh.
 */
private async refreshAccessToken(refreshToken: string): Promise<string | null> {
  // ...
}
```

### Git y Commits

- âœ… Commits atÃ³micos y descriptivos
- âœ… Usar Conventional Commits: `feat:`, `fix:`, `refactor:`, `test:`, etc.
- âœ… Branch naming: `feature/`, `fix/`, `refactor/`
- âœ… PRs pequeÃ±os y enfocados

---

## ðŸ§¹ Code Quality

> **ðŸ“š Referencia especializada:** Consulta `.cursor/agents/code-reviewer.md` para checklist completo de code review, identificaciÃ³n de code smells, y mejores prÃ¡cticas de calidad.

### Linting y Formatting

- âœ… Usar ESLint con reglas de React Native
- âœ… Usar Prettier para formateo consistente
- âœ… Configurar pre-commit hooks (Husky)
- âœ… Integrar en CI/CD

### Code Review Checklist

- âœ… Â¿El cÃ³digo sigue los patrones del proyecto?
- âœ… Â¿Hay tests para nueva funcionalidad?
- âœ… Â¿Se manejan errores apropiadamente?
- âœ… Â¿Es accesible?
- âœ… Â¿Hay performance issues?
- âœ… Â¿La seguridad estÃ¡ considerada?
- âœ… Â¿Los tipos estÃ¡n bien definidos?

### Refactoring

- âœ… Refactorizar cuando el cÃ³digo se duplica (DRY)
- âœ… Mantener funciones pequeÃ±as y enfocadas
- âœ… Extraer constantes mÃ¡gicas a constantes nombradas
- âœ… Mejorar nombres de variables/funciones cuando sea necesario

---

## ðŸ—ï¸ Estructura de Archivos

### OrganizaciÃ³n

```
app/              # Pantallas (Expo Router)
components/       # Componentes reutilizables (Atomic Design)
hooks/            # Custom hooks
services/         # LÃ³gica de negocio y API
  â”œâ”€â”€ modes/      # Implementaciones (mock/rest)
providers/        # Context providers
utils/            # Utilidades puras
config/           # ConfiguraciÃ³n
theme/            # Design tokens
```

### Reglas

- âœ… Un componente por archivo
- âœ… Archivos relacionados cerca entre sÃ­
- âœ… Usar `index.ts` para exports pÃºblicos
- âœ… Mantener estructura plana cuando sea posible (evitar nesting excesivo)

---

## ðŸŒ InternacionalizaciÃ³n (i18n)

### PreparaciÃ³n para i18n

- âœ… No hardcodear strings de texto en componentes
- âœ… Preparar estructura para traducciones
- âœ… Usar keys descriptivos: `auth.login.title` no `loginTitle`

---

## ðŸ“± Expo EspecÃ­fico

### ConfiguraciÃ³n

- âœ… Mantener `app.config.ts` actualizado
- âœ… Configurar deep linking apropiadamente
- âœ… Configurar esquemas de URL
- âœ… Validar variables de entorno

### Build y Deploy

- âœ… Usar EAS Build para builds nativos
- âœ… Configurar diferentes environments (dev, stage, prod)
- âœ… Validar configuraciÃ³n antes de deploy
- âœ… Usar versionado semÃ¡ntico

---

## ðŸ” Debugging

### Herramientas

- âœ… Usar React Native Debugger
- âœ… Usar Flipper para debugging avanzado
- âœ… Logs estructurados en desarrollo
- âœ… No loguear informaciÃ³n sensible

### Logging

```typescript
// âœ… BUENO: Logs condicionales
if (__DEV__) {
  console.log("ðŸ”‘ AccessToken updated:", token ? "set" : "cleared");
}

// âŒ MALO: Logs en producciÃ³n
console.log("User token:", token);
```

---

## âœ… Checklist Pre-Deploy

Antes de hacer deploy a producciÃ³n:

- [ ] Todos los tests pasan
- [ ] No hay warnings de TypeScript
- [ ] No hay console.logs de debug
- [ ] Variables de entorno configuradas correctamente
- [ ] Bundle size optimizado
- [ ] Performance testing realizado
- [ ] Security audit realizado
- [ ] Accesibilidad verificada
- [ ] DocumentaciÃ³n actualizada

---

## ðŸ§ª InvestigaciÃ³n UX y Usabilidad

> **ðŸ“š Referencia especializada:** Consulta `.cursor/agents/ux-researcher.md` para metodologÃ­as completas de investigaciÃ³n UX, diseÃ±o de pruebas de usabilidad, anÃ¡lisis de comportamiento, creaciÃ³n de personas, journey mapping, y validaciÃ³n de diseÃ±os.

### Principios de UX Research

- âœ… Investigar antes de diseÃ±ar (discovery research)
- âœ… Validar diseÃ±os con usuarios reales
- âœ… Medir comportamiento real, no solo opiniones
- âœ… Combinar mÃ©todos cualitativos y cuantitativos
- âœ… Iterar basÃ¡ndose en datos, no suposiciones

### MÃ©tricas Clave para Monitorear

**Engagement:**
- Daily/Monthly Active Users (DAU/MAU)
- Sesiones por usuario
- Tiempo en app
- RetenciÃ³n (D1, D7, D30)

**ConversiÃ³n:**
- BÃºsqueda â†’ Ver detalles
- Ver detalles â†’ Iniciar reserva
- Iniciar reserva â†’ Completar pago
- Tasa de Ã©xito de pago

**FricciÃ³n:**
- Puntos de abandono en funnel
- Tasa de error
- Tiempo para completar tareas clave
- Tickets de soporte

### Pruebas de Usabilidad

- âœ… Probar flujos crÃ­ticos regularmente (login, booking, pago)
- âœ… Reclutar 5-8 usuarios por ronda de testing
- âœ… Observar comportamiento, no solo preguntar
- âœ… Documentar pain points y oportunidades
- âœ… Priorizar mejoras por impacto y esfuerzo

### Accesibilidad

- âœ… Cumplir con WCAG 2.1 AA como mÃ­nimo
- âœ… Probar con lectores de pantalla (VoiceOver/TalkBack)
- âœ… Verificar navegaciÃ³n por teclado
- âœ… Validar contraste de colores
- âœ… Incluir usuarios con discapacidades en pruebas

### Feedback del Usuario

- âœ… Implementar encuestas in-app estratÃ©gicamente
- âœ… Analizar reviews de app stores
- âœ… Monitorear tickets de soporte
- âœ… Realizar entrevistas de usuario periÃ³dicas
- âœ… Analizar sesiones grabadas (con consentimiento)

---

## ðŸ“– Recursos y Referencias

- [React Native Best Practices](https://reactnative.dev/docs/performance)
- [Expo Documentation](https://docs.expo.dev/)
- [TanStack Query Docs](https://tanstack.com/query/latest)
- [TypeScript Handbook](https://www.typescriptlang.org/docs/)
- [OWASP Mobile Security](https://owasp.org/www-project-mobile-security/)

---

## ðŸŽ¯ Principios Fundamentales

1. **Clarity over Cleverness**: CÃ³digo claro y legible siempre
2. **Fail Fast**: Validar y fallar temprano
3. **Security First**: Seguridad desde el diseÃ±o
4. **Test Everything**: Tests para cÃ³digo crÃ­tico
5. **User Experience**: Performance y UX son prioritarios
6. **Maintainability**: CÃ³digo mantenible a largo plazo

---

_Ãšltima actualizaciÃ³n: Generado automÃ¡ticamente para el proyecto_
